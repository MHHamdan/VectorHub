// VectorSearchPrototype.java
// Prototype for a simple vector search component in VectorSphere using Java.
// This example demonstrates calculating cosine similarity between a query vector
// and a set of stored vectors (simulated vector database).

import java.util.ArrayList;
import java.util.List;

public class VectorSearchPrototype {

    /**
     * Computes the dot product of two vectors.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @return The dot product as a double.
     */
    public static double dotProduct(List<Double> v1, List<Double> v2) {
        double result = 0.0;
        for (int i = 0; i < v1.size(); i++) {
            result += v1.get(i) * v2.get(i);
        }
        return result;
    }

    /**
     * Computes the Euclidean norm (magnitude) of a vector.
     * @param v The vector.
     * @return The norm as a double.
     */
    public static double norm(List<Double> v) {
        double sum = 0.0;
        for (Double val : v) {
            sum += val * val;
        }
        return Math.sqrt(sum);
    }

    /**
     * Computes the cosine similarity between two vectors.
     * Returns a value between -1 and 1, where 1 indicates identical orientation.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @return The cosine similarity.
     */
    public static double cosineSimilarity(List<Double> v1, List<Double> v2) {
        double norm1 = norm(v1);
        double norm2 = norm(v2);

        // To avoid division by zero, check if either norm is zero.
        if (norm1 == 0.0 || norm2 == 0.0) {
            return 0.0;
        }
        return dotProduct(v1, v2) / (norm1 * norm2);
    }

    public static void main(String[] args) {
        // Define a query vector (could be an embedding generated by a model).
        List<Double> query = new ArrayList<>();
        query.add(0.1);
        query.add(0.3);
        query.add(0.5);

        // Simulated vector database (each vector might represent an embedded document).
        List<List<Double>> vectorDB = new ArrayList<>();

        // Vector 0
        List<Double> vector0 = new ArrayList<>();
        vector0.add(0.2);
        vector0.add(0.4);
        vector0.add(0.6);
        vectorDB.add(vector0);

        // Vector 1
        List<Double> vector1 = new ArrayList<>();
        vector1.add(0.0);
        vector1.add(0.1);
        vector1.add(0.0);
        vectorDB.add(vector1);

        // Vector 2
        List<Double> vector2 = new ArrayList<>();
        vector2.add(0.3);
        vector2.add(0.3);
        vector2.add(0.3);
        vectorDB.add(vector2);

        // Variables to track the best matching vector.
        int bestMatchIndex = -1;
        double bestSimilarity = -Double.MAX_VALUE;

        // Iterate over the vector database to compute similarity scores.
        for (int i = 0; i < vectorDB.size(); i++) {
            double sim = cosineSimilarity(query, vectorDB.get(i));
            System.out.println("Similarity with vector " + i + ": " + sim);

            // Update the best match if the current similarity is higher.
            if (sim > bestSimilarity) {
                bestSimilarity = sim;
                bestMatchIndex = i;
            }
        }

        // Output the result.
        System.out.println("Best match index: " + bestMatchIndex + " with similarity: " + bestSimilarity);
    }
}
