// vector_search_prototype.cpp
// Prototype for a simple vector search component in VectorSphere.
// This example demonstrates calculating cosine similarity between a query vector
// and a set of stored vectors (vector database).

#include <iostream>
#include <vector>
#include <cmath>
#include <limits>

using std::vector;
using std::cout;
using std::endl;

// Function to compute the dot product of two vectors.
float dot_product(const vector<float>& v1, const vector<float>& v2) {
    float result = 0.0f;
    for (size_t i = 0; i < v1.size(); i++) {
        result += v1[i] * v2[i];
    }
    return result;
}

// Function to compute the Euclidean norm of a vector.
float norm(const vector<float>& v) {
    float sum = 0.0f;
    for (float val : v) {
        sum += val * val;
    }
    return std::sqrt(sum);
}

// Function to compute the cosine similarity between two vectors.
// Returns a value between -1 and 1, where 1 means identical orientation.
float cosine_similarity(const vector<float>& v1, const vector<float>& v2) {
    float n1 = norm(v1);
    float n2 = norm(v2);
    
    // To avoid division by zero, check if any norm is zero.
    if (n1 == 0.0f || n2 == 0.0f) {
        return 0.0f;
    }
    
    return dot_product(v1, v2) / (n1 * n2);
}

int main() {
    // Define a query vector (this could be an embedding generated by a model).
    vector<float> query = {0.1f, 0.3f, 0.5f};
    
    // Simulated vector database (each vector might represent an embedded document).
    vector<vector<float>> vector_db = {
        {0.2f, 0.4f, 0.6f},
        {0.0f, 0.1f, 0.0f},
        {0.3f, 0.3f, 0.3f}
    };
    
    // Variables to track the best matching vector.
    int best_match_index = -1;
    float best_similarity = -std::numeric_limits<float>::infinity();
    
    // Iterate over the vector database to compute similarity scores.
    for (size_t i = 0; i < vector_db.size(); i++) {
        float sim = cosine_similarity(query, vector_db[i]);
        cout << "Similarity with vector " << i << ": " << sim << endl;
        
        // Update the best match if the current similarity is higher.
        if (sim > best_similarity) {
            best_similarity = sim;
            best_match_index = static_cast<int>(i);
        }
    }
    
    // Output the result.
    cout << "Best match index: " << best_match_index 
         << " with similarity: " << best_similarity << endl;
    
    return 0;
}
